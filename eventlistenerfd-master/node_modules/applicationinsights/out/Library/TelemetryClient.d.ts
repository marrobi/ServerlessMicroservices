import Config = require("./Config");
import Context = require("./Context");
import Contracts = require("../Declarations/Contracts");
import Channel = require("./Channel");
import Telemetry = require("./TelemetryTypes/Telemetry");
import DependencyTelemetry = require("./TelemetryTypes/DependencyTelemetry");
import EventTelemetry = require("./TelemetryTypes/EventTelemetry");
import TraceTelemetry = require("./TelemetryTypes/TraceTelemetry");
import ExceptionTelemetry = require("./TelemetryTypes/ExceptionTelemetry");
import RequestTelemetry = require("./TelemetryTypes/RequestTelemetry");
import MetricTelemetry = require("./TelemetryTypes/MetricTelemetry");
import FlushOptions = require("./FlushOptions");
import TelemetryType = require("./TelemetryTypes/TelemetryType");
/**
 * Application Insights telemetry client provides interface to track telemetry items, register telemetry initializers and
 * and manually trigger immediate sending (flushing)
 */
declare class TelemetryClient {
    private _telemetryProcessors;
    config: Config;
    context: Context;
    commonProperties: {
        [key: string]: string;
    };
    channel: Channel;
    /**
     * Constructs a new client of the client
     * @param iKey the instrumentation key to use (read from environment variable if not specified)
     */
    constructor(iKey?: string);
    /**
     * Log a trace message
     * @param telemetry      Object encapsulating tracking options
     */
    trackTrace(telemetry: TraceTelemetry): void;
    /**
     * Log a numeric value that is not associated with a specific event. Typically used to send regular reports of performance indicators.
     * To send a single measurement, use just the first two parameters. If you take measurements very frequently, you can reduce the
     * telemetry bandwidth by aggregating multiple measurements and sending the resulting average at intervals.
     * @param telemetry      Object encapsulating tracking options
     */
    trackMetric(telemetry: MetricTelemetry): void;
    /**
     * Log an exception
     * @param telemetry      Object encapsulating tracking options
     */
    trackException(telemetry: ExceptionTelemetry): void;
    /**
     * Log a user action or other occurrence.
     * @param telemetry      Object encapsulating tracking options
     */
    trackEvent(telemetry: EventTelemetry): void;
    /**
     * Log a user action or other occurrence.
     * @param telemetry      Object encapsulating tracking options
     */
    trackRequest(telemetry: RequestTelemetry): void;
    /**
     * Log a dependency. Note that the default client will attempt collect dependencies automatically so only use this for dependencies
     * that aren't automatically captured or if you've disabled custom dependencies.
     *
     * @param telemetry      Object encapsulating tracking option
     * */
    trackDependency(telemetry: DependencyTelemetry): void;
    /**
     * Immediately send all queued telemetry.
     * @param options Flush options, including indicator whether app is crashing and callback
     */
    flush(options?: FlushOptions): void;
    /**
     * Generic track method for all telemetry types
     * @param data the telemetry to send
     * @param telemetryType specify the type of telemetry you are tracking from the list of Contracts.DataTypes
     */
    track(telemetry: Telemetry, telemetryType: TelemetryType): void;
    /**
     * Adds telemetry processor to the collection. Telemetry processors will be called one by one
     * before telemetry item is pushed for sending and in the order they were added.
     *
     * @param telemetryProcessor function, takes Envelope, and optional context object and returns boolean
     */
    addTelemetryProcessor(telemetryProcessor: (envelope: Contracts.Envelope, contextObjects?: {
        [name: string]: any;
    }) => boolean): void;
    clearTelemetryProcessors(): void;
    private runTelemetryProcessors(envelope, contextObjects);
}
export = TelemetryClient;
